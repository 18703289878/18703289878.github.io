---
published: true
title: Modern Operating Systems chapter 2 notes threads
category: Operating system
tags: 
  - Operating system
layout: post
---

进入thread线程的总结。

# Thread Usage

我们已经有了process，为什么还需要thread线程呢？原因有以下四个：
1. 在一个process里本就进行着各种活动（或者说任务），将一个process decompose成不同的threads使程序设计更为简单了，并且，同一个process的threads之间可以共享address space，这使threads
可以完成processes完成不了（或者完成困难）的任务。
2. thread is lighter than process。 所以thread的创建等过程比process更简单。
3. 实现了thread之后某方面的performance比没实现更强(overlap)。
4. 在多CPU系统中实现真正的并行。

# Thread Definition

A sequential execution stream within a process is called a thread(also called lightweight process).

同一个prcess的threads之间共享address space and OS resources，所以它们之间可以直接通信。
Each thread has its own stack,CPU registers,etc.

# The Classcial Thread Model

从另一角度看待process，process其实是一组related resources的集合，process的工作就是分配resources让具体的threads去执行任务。

## No Protection Between Threads

为什么threads之间不需要保护呢？对于processes来说，不同的process可能是由不同的user创建的，它们可能会产生竞争关系，这时候需要对它们的相关资源进行保护，
而对于threads来说，它们由同一user创建，是要相互配合去完成某一项任务，它们的目的是合作，所以不需要保护。

## Public resources and private resources

threads之间也不是所有的resources都共享的，事实上也不可能全部共享，因为它们也需要完成**不同**的任务，这就意味着它们需要记录各自的state,stack and registers etc.
让我们来看一下threads之间什么是共享的什么是单一thread独有的。

![0](https://raw.githubusercontent.com/Logos23333/Logos23333.github.io/master/_posts/image/os/1.png)

## Why each thread needs its own stack

为什么每个thread需要各自专属的stack呢？每个线程都需要保存各自被调用的过程，比如，X调用Y，Y又
调用Z，那么当Z执行时，X/Y/Z的信息会保存在各自的堆栈中。

## Disadvantages

实现threads也不是一点缺点没有，它的缺点有两个：
1. 它使得模型变得更加复杂了。
2. 因为thread共享一些resources的关系可能出现问题。

# POSIX Threads

>To make it possible to write portable threaded programs, IEEE has defined a standard for threads in IEEE standard 1003.1c. The threads package it defines is
called Pthreads. Most UNIX systems support it. The standard defines over 60 function calls, which is far too many to go over here. Instead, we will just describe
a few of the major ones to give an idea of how it works. 

![0](https://raw.githubusercontent.com/Logos23333/Logos23333.github.io/master/_posts/image/os/2.png)

# Implementating Threads

实现thread有两种主要的方式：user space and the kernel. A hybrid implementation is also possible.

![0](https://raw.githubusercontent.com/Logos23333/Logos23333.github.io/master/_posts/image/os/3.png)

上图向我们展示了如何分别在user space和kernel中实现threads。

## Implementating Threads in User Space

在User Space中实现threads一个很重要的特点就是，kernel对与threads一无所知。像process一样，threads也要实现类似于*process table*一样的东西，在threads中，要实现**thread table**，
在user space中，thread table由run-time system管理，

