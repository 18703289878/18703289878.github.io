---
published: true
title: 计算机网络Chapter 2读书笔记
category: computer networking
tags: 
  - computer networking
layout: post
---

![0](https://raw.githubusercontent.com/Logos23333/Logos23333.github.io/master/_posts/image/computernetworking/1.png)

# 一些基本概念

## socket

计算机网络课程中会经常提到socket，但一个socket的含义可以有很多种，有些同学会经常弄混。以下对socket的解释摘自谢希仁老师的《计算机网络》一书。
>socket的含义：  
* 允许应用程序访问联网的应用编程接口API，称为socket API,是连接application layer和transport layer的门，自顶向下这本书的socket就是指这个意思。
* 端口号拼接到IP地址即做socket或插口。
* socket API中使用的一个函数名也叫做socket。
* 调用socket函数时，其返回值称为socket描述符，简称为socket。

# Web和HTTP

HTTP是采用TCP协议的应用层协议。它是一个无状态（stateless protocol），因为它不保存关于客户的任何信息。(平时我们的浏览器是用什么方式保存我们的信息的？)  
每个请求/响应是经一个单独的TCP连接发送，还是所有的请求及其响应经相同的TCP连接发送？前者是**非持续连接**（non-persistent connection），而后者是**持续连接**（persistent connection）。

## 三次握手

在浏览器和Web服务器之间发起一个TCP连接，涉及一次**三次握手**过程，所谓三次握手就是：  
1.客户向服务器发送一个小TCP报文段请求连接。
2.服务器用一个小TCP报文段做出确认和响应。到这里占用了**一个**RTT。
3.客户向服务器请求文件。

而总的响应时间还应包括：		
4.服务器发送文件的传输时延。
5.服务器向客户发送数据的时间。

所以，总的响应时间就是两个RTT加上服务器传输HTML文件的时间（传输时延）。

## HTTP的报文格式

### HTTP请求报文

下面提供了一个典型的HTTP请求报文：  

	GET /somedir/page.html HTTP/1.1
	Host: www.someschool.edu
	Connection: close
	User-agent: Mozilla/5.0
	Accept-language: fr
	
HTTP请求报文的第一行叫做**请求行**（request line），其后继的行叫做**首部行**（header line），HTTP请求报文的通用格式如下：

![0](https://raw.githubusercontent.com/Logos23333/Logos23333.github.io/master/_posts/image/computernetworking/2.png)

### HTTP响应报文

下面提供了一个典型的HTTP响应报文：

	HTTP/1.1 200 OK
	Connection: close
	Date: Tue, 09 Aug 2011 15:44:04 GMT
	Server: Apache/2.2.3 (CentOS)
	Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
	Content-Length: 6821
	Content-Type: text/html
	(data data data data data ...)
	
## cookie

前面提到HTTP服务器本身是无状态的(stateless)，然而Web站点通常希望能够识别用户（比如购物界面就不希望点击其它网页后购物车里的东西都没了），目前大多数商务Web站点都使用了cookie。

使用cookie是一个这样的过程：  
1.客户请求访问 Amazon Web服务器发送请求报文。
2.报文到达Amazon Web服务器后，该Web站点为此客户产生一个唯一的识别码并以此作为索引在它的后端数据库中产生一个表项。
3.服务器发送响应报文，此响应报文会将用户浏览器中此站点的cookie设为唯一的标识符，由用户浏览器进行管理。
4.客户第二次访问Amazon Web服务器，此时的请求报文会带着自己的cookie信息，也就是说服务器知道客户是之前的那个人，于是产生了特定动作。

## Web缓存

**Web缓存器**（Web cache）也叫**代理服务器**（proxy server），我们可以通过配置用户的浏览器，使得用户所有的HTTP请求首先指向Web缓存器。举例来说：

1. The browser establishes a TCP connection to the Web cache and sends an HTTP request for the object to the Web cache.  浏览器向代理服务器发送HTTP请求。
2. The Web cache checks to see if it has a copy of the object stored locally. If it does, the Web cache returns the object within an HTTP response message to the client browser. 如果代理服务器有缓存，直接返回该对象。
3. If the Web cache does not have the object, the Web cache opens a TCP connection to the origin server, that is, to www.someschool.edu. The Web cache then sends an HTTP request for the object into the cache-to-server TCP connection. After receiving this request, the origin server sends the object within an HTTP response to the Web cache.
如果代理服务器没有该页面的缓存，由该代理服务器发送一个对该对象的HTTP请求。
4. When the Web cache receives the object, it stores a copy in its local storage and sends a copy, within an HTTP response message, to the client browser (over the existing TCP connection between the client browser and the Web cache).
当代理服务器接受到该对象时，在本地存储一个副本，并发送到客户端。

Web缓存的作用有两点：
* 对于客户来说，Web缓存器能够大大减少对客户请求的响应时间。
* 对于整个因特网来说，Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。

Web缓存给我们带来的作用是巨大的，但也引入了新的问题，即存放在缓存器中的对象副本可能是陈旧的。  
幸运的是HTTP协议中有一种机制，允许缓存器证实它的对象是最新的，这种机制就是**条件GET（conditional GET）方法。如果请求报文使用**GET**方法且包含一个`If-Modified-Since`首部行，那么这个HTTP请求就是一个条件GET请求报文。

意思就是说，Web缓存中会保存缓存页面时的时间，在这个时间后如果页面未曾修改过（由Web服务器告知），则发送此缓存。

# 文件传输协议：FTP

