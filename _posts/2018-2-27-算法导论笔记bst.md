---
published: true
title: 《Introduction to Algorithm》notes:Binary search tree
category: Algorithm
tags: 
  - 算法
layout: post
---

什么是Binary search tree(BST,二叉检索树)?首先，它是一个二叉树，其次，它是按照一定规则组织的二叉树，即左结点值比根节点值小，右结点值大于或等于根节点值，根据这种规则组织的二叉树就是BST。

# Inorder-tree-walk

BST的一个很常见的应用就是，如果中序(inorder)遍历这棵树，可以得到一个递增的一组序列。

	//pseudocode: INORDER-TREE-WALK
	if x!=null
		inorder-tree-walk(x.left)
		print x.key
		inorder-tree-walk(x.right)
		
## proof about inorder travel

如何证明中序遍历整棵树花了 Θ(n)的时间？
1.因为必须遍历所有结点，所以此算法一定是Ω(n)的，下面只需证明此算法是O(n)的即可。
2.根据伪代码，可以得出 `T(n)<=T(k)+T(n-k-1)+d`，使用前面的substitution method就可以证明此算法是O(n)的。

## Exercise

### 12.1-1 

EASY.

### 12.1-2

What is the difference between the binary-search-tree property and the min-heap property (see page 153)? Can the min-heap property be used to print out the keys
of an n-node tree in sorted order in O(n) time? Show how, or explain why not.

Solution：
1.BST规定了左子结点小于根结点并且右子节点大于或等于根结点，而min-heap只要求其子结点小于根结点即可，没有对左和右各做要求。
2.用min-heap结构不能做到在O(n)的时间内打印出排序序列，如果能做到的话，那么就能有一个新的排序算法，这个基于比较的排序算法时间复杂度是o(n)，而根据decision tree的知识可知，基于比较的排序算法是Ω(nlogn)的。

### 12.1-3

Give a nonrecursive algorithm that performs an inorder tree walk. (Hint: An easy solution uses a stack as an auxiliary data structure. A more complicated, but elegant, solution uses no stack but assumes that we can test two pointers for equality.)

Solution：

//Stack solution
	//function:push_left(root)
	while root!=null//这个函数将该结点的所有左子树压栈
			stack.push(root)
			root=root.left
	//main function
	while x!=null
		push_left(x)//左
		print(stack.pop())//中
		push_left(x.right)//右

//Two-pointer solution
while root!=null
	while root->left!=null&&!root.visit //如果root的left没有被visit过
		root=root->left //左
	if(!root.visit) print(root) root.visit=true
	if root->right!=null&&!root->right.visit
		root=root.right
	else
		root=root.parent
		
### 12.1-4

Give recursive algorithms that perform preorder and postorder tree walks in Θ(n) time on a tree of n nodes.

	//pseudocode: PREORDER-TREE-WALK
	if x!=null
		print x.key
		inorder-tree-walk(x.left)		
		inorder-tree-walk(x.right)
		
	//pseudocode: PREORDER-TREE-WALK
	if x!=null		
		inorder-tree-walk(x.left)		
		inorder-tree-walk(x.right)
		print x.key
		
###  12.1-5

Argue that since sorting n elements takes Ω(nlogn) time in the worst case in
the comparison model, any comparison-based algorithm for constructing a binary
search tree from an arbitrary list of n elements takes Ω(nlogn) time in the worst
case.

跟12.1-2类似，基于比较，一定是Ω(nlogn)。

